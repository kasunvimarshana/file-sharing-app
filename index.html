<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed File Sharing System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(5px);
        }

        .panel h2 {
            color: white;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .file-input {
            margin-bottom: 15px;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-weight: 600;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #43e97b, #38f9d7);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(67, 233, 123, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .torrent-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .torrent-item {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .torrent-item:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateX(5px);
        }

        .torrent-info {
            color: white;
        }

        .torrent-name {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .torrent-details {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #43e97b, #38f9d7);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .peers-section {
            grid-column: 1 / -1;
        }

        .peer-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .peer-item {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            text-align: center;
            transition: all 0.3s ease;
        }

        .peer-item:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .peer-id {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .peer-status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .status-online {
            color: #43e97b;
        }

        .status-downloading {
            color: #4facfe;
        }

        .status-seeding {
            color: #38f9d7;
        }

        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #00ff00;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê Distributed File Sharing System</h1>
        
        <div class="grid">
            <div class="panel">
                <h2>üìÅ Share File</h2>
                <div class="file-input">
                    <input type="file" id="fileInput" accept="*/*">
                    <label for="fileInput" class="file-label">Choose File</label>
                </div>
                <button onclick="createTorrent()">Create Torrent</button>
                <button onclick="startSeeding()" id="seedBtn" disabled>Start Seeding</button>
            </div>

            <div class="panel">
                <h2>üì• Download</h2>
                <button onclick="refreshTorrents()">Refresh Available Files</button>
                <button onclick="simulatePeers()">Simulate Network Activity</button>
                <div class="torrent-list" id="torrentList">
                    <div style="color: white; text-align: center; opacity: 0.6;">
                        No torrents available. Create one or refresh to see simulated files.
                    </div>
                </div>
            </div>

            <div class="panel peers-section">
                <h2>üë• Network Peers</h2>
                <div class="peer-list" id="peerList"></div>
            </div>
        </div>

        <div class="log" id="logOutput"></div>
    </div>

    <script>
        class TorrentSystem {
            constructor() {
                this.peers = new Map();
                this.torrents = new Map();
                this.downloads = new Map();
                this.myPeerId = 'peer-' + Math.random().toString(36).substr(2, 9);
                this.isSeeding = false;
                this.selectedFile = null;
                
                this.log(`System initialized with Peer ID: ${this.myPeerId}`);
                this.initializePeers();
            }

            initializePeers() {
                // Simulate some initial peers
                const peerNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Echo'];
                peerNames.forEach((name, i) => {
                    const peerId = `peer-${name.toLowerCase()}-${i}`;
                    this.peers.set(peerId, {
                        id: peerId,
                        name: name,
                        status: Math.random() > 0.5 ? 'online' : 'seeding',
                        files: [],
                        lastSeen: Date.now()
                    });
                });
                this.updatePeerDisplay();
            }

            log(message) {
                const logElement = document.getElementById('logOutput');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
            }

            createTorrent() {
                const fileInput = document.getElementById('fileInput');
                if (!fileInput.files[0]) {
                    this.log('‚ùå No file selected');
                    return;
                }

                this.selectedFile = fileInput.files[0];
                const fileHash = this.generateHash(this.selectedFile.name + this.selectedFile.size);
                
                const torrent = {
                    hash: fileHash,
                    name: this.selectedFile.name,
                    size: this.selectedFile.size,
                    chunks: Math.ceil(this.selectedFile.size / 1024), // 1KB chunks
                    peers: [this.myPeerId],
                    created: Date.now()
                };

                this.torrents.set(fileHash, torrent);
                this.log(`‚úÖ Created torrent for: ${this.selectedFile.name} (${this.formatBytes(this.selectedFile.size)})`);
                this.log(`üìã Torrent hash: ${fileHash}`);
                
                document.getElementById('seedBtn').disabled = false;
                this.updateTorrentDisplay();
            }

            startSeeding() {
                if (!this.selectedFile) {
                    this.log('‚ùå No file to seed');
                    return;
                }

                this.isSeeding = true;
                this.log(`üå± Started seeding: ${this.selectedFile.name}`);
                
                // Update peer status
                if (this.peers.has(this.myPeerId)) {
                    this.peers.get(this.myPeerId).status = 'seeding';
                } else {
                    this.peers.set(this.myPeerId, {
                        id: this.myPeerId,
                        name: 'You',
                        status: 'seeding',
                        files: [this.selectedFile.name],
                        lastSeen: Date.now()
                    });
                }

                this.updatePeerDisplay();
                document.getElementById('seedBtn').textContent = 'Seeding...';
                document.getElementById('seedBtn').disabled = true;
            }

            simulatePeers() {
                this.log('üîÑ Simulating network activity...');
                
                // Randomly update peer statuses
                for (let [peerId, peer] of this.peers) {
                    if (peerId !== this.myPeerId) {
                        const statuses = ['online', 'downloading', 'seeding'];
                        peer.status = statuses[Math.floor(Math.random() * statuses.length)];
                        peer.lastSeen = Date.now();
                    }
                }

                // Add some simulated torrents
                const sampleFiles = [
                    { name: 'Ubuntu_22.04.iso', size: 3500000000 },
                    { name: 'Movie_Sample.mp4', size: 1200000000 },
                    { name: 'Music_Album.zip', size: 120000000 },
                    { name: 'Software_Package.tar.gz', size: 450000000 },
                    { name: 'Dataset.csv', size: 89000000 }
                ];

                sampleFiles.forEach(file => {
                    const hash = this.generateHash(file.name + file.size);
                    if (!this.torrents.has(hash)) {
                        const availablePeers = Array.from(this.peers.keys()).filter(id => 
                            this.peers.get(id).status === 'seeding'
                        );
                        
                        this.torrents.set(hash, {
                            hash: hash,
                            name: file.name,
                            size: file.size,
                            chunks: Math.ceil(file.size / 1024),
                            peers: availablePeers.slice(0, Math.floor(Math.random() * 3) + 1),
                            created: Date.now() - Math.random() * 86400000
                        });
                    }
                });

                this.updatePeerDisplay();
                this.updateTorrentDisplay();
                this.log('‚úÖ Network activity simulated');
            }

            refreshTorrents() {
                this.log('üîÑ Refreshing available torrents...');
                this.updateTorrentDisplay();
                this.log(`üìã Found ${this.torrents.size} available torrents`);
            }

            downloadTorrent(hash) {
                const torrent = this.torrents.get(hash);
                if (!torrent) {
                    this.log('‚ùå Torrent not found');
                    return;
                }

                if (this.downloads.has(hash)) {
                    this.log('‚ö†Ô∏è Already downloading this file');
                    return;
                }

                this.log(`üì• Starting download: ${torrent.name}`);
                this.log(`üë• Available peers: ${torrent.peers.length}`);

                const download = {
                    hash: hash,
                    torrent: torrent,
                    progress: 0,
                    downloadedChunks: 0,
                    totalChunks: torrent.chunks,
                    startTime: Date.now(),
                    peers: [...torrent.peers]
                };

                this.downloads.set(hash, download);
                this.simulateDownload(hash);
                this.updateTorrentDisplay();
            }

            simulateDownload(hash) {
                const download = this.downloads.get(hash);
                if (!download) return;

                const interval = setInterval(() => {
                    if (download.downloadedChunks >= download.totalChunks) {
                        clearInterval(interval);
                        this.completeDownload(hash);
                        return;
                    }

                    // Simulate downloading chunks from different peers
                    const chunksThisRound = Math.min(
                        Math.floor(Math.random() * 5) + 1,
                        download.totalChunks - download.downloadedChunks
                    );
                    
                    download.downloadedChunks += chunksThisRound;
                    download.progress = (download.downloadedChunks / download.totalChunks) * 100;

                    const randomPeer = download.peers[Math.floor(Math.random() * download.peers.length)];
                    this.log(`üì¶ Downloaded ${chunksThisRound} chunks from ${randomPeer}`);

                    this.updateTorrentDisplay();
                }, 1000 + Math.random() * 2000);
            }

            completeDownload(hash) {
                const download = this.downloads.get(hash);
                if (!download) return;

                const duration = (Date.now() - download.startTime) / 1000;
                this.log(`‚úÖ Download completed: ${download.torrent.name}`);
                this.log(`‚è±Ô∏è Time taken: ${duration.toFixed(1)}s`);
                this.log(`üöÄ Average speed: ${this.formatBytes(download.torrent.size / duration)}/s`);

                // Add to our seeded files
                if (this.peers.has(this.myPeerId)) {
                    this.peers.get(this.myPeerId).files.push(download.torrent.name);
                }

                this.downloads.delete(hash);
                this.updateTorrentDisplay();
            }

            updateTorrentDisplay() {
                const container = document.getElementById('torrentList');
                if (this.torrents.size === 0) {
                    container.innerHTML = '<div style="color: white; text-align: center; opacity: 0.6;">No torrents available. Create one or refresh to see simulated files.</div>';
                    return;
                }

                container.innerHTML = Array.from(this.torrents.values()).map(torrent => {
                    const download = this.downloads.get(torrent.hash);
                    const isDownloading = !!download;
                    const progress = download ? download.progress : 0;

                    return `
                        <div class="torrent-item">
                            <div class="torrent-info">
                                <div class="torrent-name">${torrent.name}</div>
                                <div class="torrent-details">
                                    Size: ${this.formatBytes(torrent.size)} | 
                                    Peers: ${torrent.peers.length} | 
                                    Chunks: ${torrent.chunks}
                                </div>
                                ${isDownloading ? `
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${progress}%"></div>
                                    </div>
                                    <div style="font-size: 0.8em; opacity: 0.8;">
                                        ${progress.toFixed(1)}% complete
                                    </div>
                                ` : ''}
                            </div>
                            <div>
                                ${isDownloading ? 
                                    '<button disabled>Downloading...</button>' :
                                    `<button onclick="torrentSystem.downloadTorrent('${torrent.hash}')">Download</button>`
                                }
                            </div>
                        </div>
                    `;
                }).join('');
            }

            updatePeerDisplay() {
                const container = document.getElementById('peerList');
                container.innerHTML = Array.from(this.peers.values()).map(peer => {
                    const statusClass = `status-${peer.status}`;
                    const statusText = peer.status.charAt(0).toUpperCase() + peer.status.slice(1);
                    
                    return `
                        <div class="peer-item">
                            <div class="peer-id">${peer.name}</div>
                            <div class="peer-status ${statusClass}">${statusText}</div>
                            <div style="font-size: 0.8em; opacity: 0.6;">
                                ${peer.files ? `Files: ${peer.files.length}` : 'No files'}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            generateHash(input) {
                let hash = 0;
                for (let i = 0; i < input.length; i++) {
                    const char = input.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(8, '0');
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Initialize the system
        const torrentSystem = new TorrentSystem();

        // Event handlers
        function createTorrent() {
            torrentSystem.createTorrent();
        }

        function startSeeding() {
            torrentSystem.startSeeding();
        }

        function refreshTorrents() {
            torrentSystem.refreshTorrents();
        }

        function simulatePeers() {
            torrentSystem.simulatePeers();
        }

        // Auto-refresh peer status every 10 seconds
        setInterval(() => {
            torrentSystem.updatePeerDisplay();
        }, 10000);
    </script>
</body>
</html>