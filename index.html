<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P File Share - Advanced Peer-to-Peer Transfer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 15px 25px;
            margin-top: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-weight: 500;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .peer-id-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 15px;
        }

        .peer-id-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .peer-id-display {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 12px 16px;
        }

        .peer-id-text {
            flex: 1;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .card-icon {
            width: 50px;
            height: 50px;
            border-radius: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
        }

        .connection-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .step-card {
            background: linear-gradient(135deg, #f8f9ff, #e8f0ff);
            border: 2px solid #e3ebff;
            border-radius: 15px;
            padding: 25px;
            position: relative;
            transition: all 0.3s ease;
        }

        .step-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .step-number {
            position: absolute;
            top: -15px;
            left: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .step-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            margin-top: 5px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            min-height: 44px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #c82333);
        }

        .btn-danger:hover {
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .btn-success:hover {
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-label {
            display: block;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .textarea {
            min-height: 120px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .code-display {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
        }

        .code-display pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            color: #333;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: #5a67d8;
        }

        .file-drop-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #f8f9ff, #e8f0ff);
            margin-bottom: 25px;
        }

        .file-drop-area:hover, .file-drop-area.drag-over {
            border-color: #5a67d8;
            background: linear-gradient(135deg, #e8f0ff, #d6e8ff);
            transform: translateY(-2px);
        }

        .file-drop-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-drop-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .file-drop-subtext {
            color: #666;
            font-size: 0.9rem;
        }

        .file-list {
            display: grid;
            gap: 15px;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .file-icon {
            width: 45px;
            height: 45px;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .file-details h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .file-meta {
            color: #666;
            font-size: 0.9rem;
        }

        .file-actions {
            display: flex;
            gap: 10px;
        }

        .progress-container {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }

        .peer-list {
            display: grid;
            gap: 15px;
        }

        .peer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(135deg, #f8f9ff, #e8f0ff);
            border: 2px solid #e3ebff;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .peer-item:hover {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .peer-info {
            flex: 1;
        }

        .peer-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .peer-id {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            color: #333;
            font-size: 0.9rem;
        }

        .peer-details {
            color: #666;
            font-size: 0.85rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9ff, #e8f0ff);
            border: 2px solid #e3ebff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .log-viewer {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 4px solid #333;
        }

        .log-entry.info {
            color: #17a2b8;
            background: rgba(23, 162, 184, 0.1);
            border-left-color: #17a2b8;
        }

        .log-entry.success {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
            border-left-color: #28a745;
        }

        .log-entry.warning {
            color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
            border-left-color: #ffc107;
        }

        .log-entry.error {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            border-left-color: #dc3545;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 10px;
            padding: 15px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border-left: 4px solid #667eea;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 350px;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left-color: #28a745;
        }

        .toast.error {
            border-left-color: #dc3545;
        }

        .toast.warning {
            border-left-color: #ffc107;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .connection-steps {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
            
            .file-item, .peer-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .file-actions, .peer-actions {
                width: 100%;
                justify-content: flex-end;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üöÄ P2P File Share</h1>
            <p>Secure peer-to-peer file transfer with advanced WebRTC technology</p>
            
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-indicator" id="connectionIndicator"></div>
                    <span id="connectionText">Initializing...</span>
                </div>
                <div class="status-item">
                    <span>üë•</span>
                    <span id="peerCount">0 peers</span>
                </div>
                <div class="status-item">
                    <span>üìä</span>
                    <span id="transferStatus">Ready</span>
                </div>
            </div>

            <div class="peer-id-section">
                <div class="peer-id-label">Your Peer ID:</div>
                <div class="peer-id-display">
                    <div class="peer-id-text" id="myPeerId">Generating...</div>
                    <button class="btn btn-secondary" onclick="p2pNode.copyToClipboard('myPeerId')" style="padding: 8px 16px; font-size: 0.9rem;">
                        üìã Copy
                    </button>
                </div>
            </div>
        </div>

        <!-- Connection Management -->
        <div class="card">
            <div class="card-header">
                <div class="card-icon">üîó</div>
                <div class="card-title">Connection Manager</div>
            </div>

            <div class="connection-steps">
                <!-- Step 1: Create Offer -->
                <div class="step-card">
                    <div class="step-number">1</div>
                    <div class="step-title">Create Connection</div>
                    <p style="margin-bottom: 20px; color: #666;">Generate a connection offer to share with another peer.</p>
                    <button class="btn" id="createOfferBtn">
                        <span>üéØ Create Offer</span>
                    </button>
                    <div class="code-display hidden" id="offerDisplay">
                        <button class="copy-btn" onclick="p2pNode.copyOfferToClipboard()">üìã Copy</button>
                        <pre id="offerText"></pre>
                    </div>
                </div>

                <!-- Step 2: Handle Offer -->
                <div class="step-card">
                    <div class="step-number">2</div>
                    <div class="step-title">Join Connection</div>
                    <div class="input-group">
                        <label class="input-label">Paste connection offer:</label>
                        <textarea class="form-control textarea" id="offerInput" placeholder="Paste the connection offer from another peer here..."></textarea>
                    </div>
                    <button class="btn btn-success" id="connectBtn">
                        <span>ü§ù Process Offer</span>
                    </button>
                    <div class="code-display hidden" id="answerDisplay">
                        <button class="copy-btn" onclick="p2pNode.copyAnswerToClipboard()">üìã Copy</button>
                        <pre id="answerText"></pre>
                    </div>
                </div>

                <!-- Step 3: Finalize Connection -->
                <div class="step-card">
                    <div class="step-number">3</div>
                    <div class="step-title">Finalize Connection</div>
                    <div class="input-group">
                        <label class="input-label">Paste connection answer:</label>
                        <textarea class="form-control textarea" id="answerInput" placeholder="Paste the connection answer you received here..."></textarea>
                    </div>
                    <button class="btn btn-success" id="finalizeBtn">
                        <span>‚úÖ Complete Connection</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- File Management -->
        <div class="card">
            <div class="card-header">
                <div class="card-icon">üìÅ</div>
                <div class="card-title">File Manager</div>
            </div>

            <div class="file-drop-area" id="fileDropArea">
                <div class="file-drop-icon">üì§</div>
                <div class="file-drop-text">Drop files here or click to browse</div>
                <div class="file-drop-subtext">Files will be shared with all connected peers</div>
                <input type="file" id="fileInput" multiple style="display: none;">
            </div>

            <div id="sharedFiles">
                <h3 style="margin-bottom: 15px; color: #333;">üì§ Your Shared Files</h3>
                <div class="file-list" id="sharedFilesList">
                    <p style="color: #666; text-align: center; padding: 20px;">No files shared yet. Drop files above to start sharing.</p>
                </div>
            </div>

            <div style="margin-top: 30px;">
                <h3 style="margin-bottom: 15px; color: #333;">üì• Available Downloads</h3>
                <div class="file-list" id="availableFiles">
                    <p style="color: #666; text-align: center; padding: 20px;">Connect to peers to discover available files...</p>
                </div>
            </div>
        </div>

        <!-- Peer Management -->
        <div class="card">
            <div class="card-header">
                <div class="card-icon">üë•</div>
                <div class="card-title">Connected Peers</div>
            </div>
            <div class="peer-list" id="peerList">
                <p style="color: #666; text-align: center; padding: 20px;">No peers connected. Use the connection manager above to join the network.</p>
            </div>
        </div>

        <!-- Statistics -->
        <div class="card">
            <div class="card-header">
                <div class="card-icon">üìä</div>
                <div class="card-title">Transfer Statistics</div>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalUploaded">0 B</div>
                    <div class="stat-label">Total Uploaded</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalDownloaded">0 B</div>
                    <div class="stat-label">Total Downloaded</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="uploadSpeed">0 B/s</div>
                    <div class="stat-label">Upload Speed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="downloadSpeed">0 B/s</div>
                    <div class="stat-label">Download Speed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="downloadCount">0</div>
                    <div class="stat-label">Active Downloads</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="uploadCount">0</div>
                    <div class="stat-label">Shared Files</div>
                </div>
            </div>
        </div>

        <!-- Activity Log -->
        <div class="card">
            <div class="card-header">
                <div class="card-icon">üìã</div>
                <div class="card-title">Activity Log</div>
                <button class="btn btn-secondary" onclick="p2pNode.clearLogs()" style="margin-left: auto; padding: 8px 16px; font-size: 0.9rem;">
                    üóëÔ∏è Clear
                </button>
            </div>
            <div class="log-viewer" id="logEntries">
                <div class="log-entry info">[System] P2P File Share initialized</div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedP2PNode {
            constructor() {
                this.peerId = this.generateSecurePeerId();
                this.peers = new Map();
                this.connections = new Map();
                this.dataChannels = new Map();
                this.sharedFiles = new Map();
                this.downloadingFiles = new Map();
                this.pendingConnections = new Map();
                this.connectionStats = new Map();
                
                // Enhanced configuration with better timeouts
                this.chunkSize = 16 * 1024; // 16KB chunks for better reliability
                this.maxConcurrentDownloads = 3;
                this.heartbeatInterval = 30000; // 30 seconds
                this.connectionTimeout = 30000; // 30 seconds (reduced from 60)
                this.iceGatheringTimeout = 15000; // 15 seconds for ICE gathering
                this.maxRetries = 3;
                
                // Statistics tracking
                this.stats = {
                    totalUploaded: 0,
                    totalDownloaded: 0,
                    uploadSpeed: 0,
                    downloadSpeed: 0,
                    sessionStart: Date.now()
                };
                
                // Enhanced WebRTC configuration
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10,
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                };
                
                this.init();
            }
            
            generateSecurePeerId() {
                const timestamp = Date.now().toString(36);
                const random = Array.from(crypto.getRandomValues(new Uint8Array(16)))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                return `peer_${timestamp}_${random}`;
            }
            
            init() {
                this.log('üöÄ Advanced P2P Node initializing...', 'info');
                this.updatePeerIdDisplay();
                this.setupEventListeners();
                this.startHeartbeat();
                this.startStatsUpdate();
                this.updateUI();
                this.log('‚úÖ Node initialization complete', 'success');
            }
            
            updatePeerIdDisplay() {
                document.getElementById('myPeerId').textContent = this.peerId;
            }
            
            log(message, type = 'info') {
                const logEntries = document.getElementById('logEntries');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logEntries.appendChild(entry);
                logEntries.scrollTop = logEntries.scrollHeight;
                
                // Keep only last 100 entries
                while (logEntries.children.length > 100) {
                    logEntries.removeChild(logEntries.firstChild);
                }
                
                console.log(`[P2P] ${message}`);
                
                // Show toast for important events
                if (type === 'success' || type === 'error' || type === 'warning') {
                    this.showToast(message, type);
                }
            }
            
            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(toast)) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, 4000);
            }
            
            clearLogs() {
                const logEntries = document.getElementById('logEntries');
                logEntries.innerHTML = '<div class="log-entry info">[System] Logs cleared</div>';
            }
            
            startHeartbeat() {
                setInterval(() => {
                    this.peers.forEach((peer, peerId) => {
                        if (peer.connected && this.dataChannels.has(peerId)) {
                            const channel = this.dataChannels.get(peerId);
                            if (channel.readyState === 'open') {
                                this.sendMessage(peerId, {
                                    type: 'heartbeat',
                                    peerId: this.peerId,
                                    timestamp: Date.now()
                                });
                            }
                        }
                    });
                    
                    // Clean up stale connections
                    this.cleanupStaleConnections();
                }, this.heartbeatInterval);
            }
            
            cleanupStaleConnections() {
                const now = Date.now();
                const staleTimeout = 120000; // 2 minutes
                
                this.peers.forEach((peer, peerId) => {
                    if (now - peer.lastSeen > staleTimeout) {
                        this.log(`üßπ Cleaning up stale connection: ${peerId}`, 'warning');
                        this.removePeer(peerId);
                    }
                });
            }
            
            startStatsUpdate() {
                setInterval(() => {
                    this.updateStats();
                }, 1000);
            }
            
            updateStats() {
                const now = Date.now();
                const timeWindow = 5000; // 5 second window
                
                let recentUploaded = 0;
                let recentDownloaded = 0;
                
                this.connectionStats.forEach(stats => {
                    const recentTransfers = stats.transfers.filter(t => now - t.timestamp < timeWindow);
                    recentUploaded += recentTransfers.filter(t => t.type === 'upload').reduce((sum, t) => sum + t.bytes, 0);
                    recentDownloaded += recentTransfers.filter(t => t.type === 'download').reduce((sum, t) => sum + t.bytes, 0);
                });
                
                this.stats.uploadSpeed = recentUploaded / (timeWindow / 1000);
                this.stats.downloadSpeed = recentDownloaded / (timeWindow / 1000);
                
                this.updateStatsDisplay();
            }
            
            updateStatsDisplay() {
                document.getElementById('totalUploaded').textContent = this.formatBytes(this.stats.totalUploaded);
                document.getElementById('totalDownloaded').textContent = this.formatBytes(this.stats.totalDownloaded);
                document.getElementById('uploadSpeed').textContent = this.formatBytes(this.stats.uploadSpeed) + '/s';
                document.getElementById('downloadSpeed').textContent = this.formatBytes(this.stats.downloadSpeed) + '/s';
                document.getElementById('downloadCount').textContent = this.downloadingFiles.size;
                document.getElementById('uploadCount').textContent = this.sharedFiles.size;
            }
            
            recordTransfer(peerId, type, bytes) {
                if (!this.connectionStats.has(peerId)) {
                    this.connectionStats.set(peerId, {
                        transfers: [],
                        totalUploaded: 0,
                        totalDownloaded: 0
                    });
                }
                
                const stats = this.connectionStats.get(peerId);
                stats.transfers.push({
                    type,
                    bytes,
                    timestamp: Date.now()
                });
                
                // Keep only recent transfers
                const cutoff = Date.now() - 60000; // 1 minute
                stats.transfers = stats.transfers.filter(t => t.timestamp > cutoff);
                
                if (type === 'upload') {
                    stats.totalUploaded += bytes;
                    this.stats.totalUploaded += bytes;
                } else {
                    stats.totalDownloaded += bytes;
                    this.stats.totalDownloaded += bytes;
                }
            }
            
            setupEventListeners() {
                // WebRTC connection setup
                document.getElementById('createOfferBtn').addEventListener('click', () => this.createOffer());
                document.getElementById('connectBtn').addEventListener('click', () => this.handleOffer());
                document.getElementById('finalizeBtn').addEventListener('click', () => this.handleAnswer());
                
                // File handling
                const fileInput = document.getElementById('fileInput');
                const fileDropArea = document.getElementById('fileDropArea');
                
                fileDropArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelection(e.target.files));
                
                // Enhanced drag and drop
                fileDropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    fileDropArea.classList.add('drag-over');
                });
                
                fileDropArea.addEventListener('dragleave', (e) => {
                    if (!fileDropArea.contains(e.relatedTarget)) {
                        fileDropArea.classList.remove('drag-over');
                    }
                });
                
                fileDropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    fileDropArea.classList.remove('drag-over');
                    this.handleFileSelection(e.dataTransfer.files);
                });
            }
            
            async createOffer() {
                const btn = document.getElementById('createOfferBtn');
                const originalText = btn.innerHTML;
                
                try {
                    btn.innerHTML = '<div class="loading-spinner"></div> Creating Offer...';
                    btn.disabled = true;
                    
                    this.log('üéØ Creating WebRTC offer...', 'info');
                    
                    const connection = new RTCPeerConnection(this.rtcConfig);
                    const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Store connection immediately
                    this.pendingConnections.set(tempId, {
                        connection,
                        created: Date.now(),
                        type: 'offer'
                    });
                    
                    // Set up connection event handlers early
                    this.setupConnectionEventHandlers(connection, tempId);
                    
                    // Create data channel BEFORE creating offer
                    const dataChannel = connection.createDataChannel('fileTransfer', {
                        ordered: true,
                        // maxPacketLifeTime: 30000,
                        maxRetransmits: null
                    });
                    
                    // Set up data channel immediately
                    this.setupDataChannelHandlers(dataChannel, tempId);
                    
                    // Create offer
                    const offer = await connection.createOffer({
                        offerToReceiveAudio: false,
                        offerToReceiveVideo: false
                    });
                    
                    await connection.setLocalDescription(offer);
                    this.log('üì° Local description set, gathering ICE candidates...', 'info');
                    
                    // Wait for ICE gathering with proper timeout and fallback
                    await this.waitForICEGathering(connection);
                    
                    const offerData = {
                        type: 'offer',
                        peerId: this.peerId,
                        offer: connection.localDescription,
                        timestamp: Date.now()
                    };
                    
                    // Update pending connection with offer data
                    this.pendingConnections.get(tempId).offerData = offerData;
                    
                    this.displayOffer(JSON.stringify(offerData, null, 2));
                    this.log('‚úÖ Offer created successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to create offer: ${error.message}`, 'error');
                    console.error('Create offer error:', error);
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
            
            async waitForICEGathering(connection) {
                return new Promise((resolve, reject) => {
                    // If ICE gathering is already complete, resolve immediately
                    if (connection.iceGatheringState === 'complete') {
                        this.log('üßä ICE gathering already complete', 'info');
                        resolve();
                        return;
                    }
                    
                    let resolved = false;
                    
                    // Set up timeout
                    const timeout = setTimeout(() => {
                        if (!resolved) {
                            resolved = true;
                            this.log('‚è∞ ICE gathering timeout, proceeding with current candidates', 'warning');
                            resolve(); // Don't reject, just proceed with what we have
                        }
                    }, this.iceGatheringTimeout);
                    
                    // Listen for ICE gathering completion
                    const onGatheringStateChange = () => {
                        this.log(`üßä ICE gathering state: ${connection.iceGatheringState}`, 'info');
                        
                        if (connection.iceGatheringState === 'complete' && !resolved) {
                            resolved = true;
                            clearTimeout(timeout);
                            connection.removeEventListener('icegatheringstatechange', onGatheringStateChange);
                            this.log('‚úÖ ICE gathering completed', 'success');
                            resolve();
                        }
                    };
                    
                    // Also listen for ICE candidates to show progress
                    const onIceCandidate = (event) => {
                        if (event.candidate) {
                            this.log(`üßä ICE candidate: ${event.candidate.type} ${event.candidate.protocol}`, 'info');
                        } else {
                            // null candidate indicates end of candidates
                            if (!resolved) {
                                resolved = true;
                                clearTimeout(timeout);
                                connection.removeEventListener('icegatheringstatechange', onGatheringStateChange);
                                connection.removeEventListener('icecandidate', onIceCandidate);
                                this.log('‚úÖ ICE candidate gathering finished', 'success');
                                resolve();
                            }
                        }
                    };
                    
                    connection.addEventListener('icegatheringstatechange', onGatheringStateChange);
                    connection.addEventListener('icecandidate', onIceCandidate);
                });
            }
            
            setupConnectionEventHandlers(connection, peerId) {
                connection.addEventListener('connectionstatechange', () => {
                    this.log(`üîó Connection state (${peerId}): ${connection.connectionState}`, 'info');
                    
                    switch (connection.connectionState) {
                        case 'connected':
                            this.handleConnectionEstablished(peerId, connection);
                            break;
                        case 'disconnected':
                        case 'failed':
                        case 'closed':
                            this.handleConnectionClosed(peerId);
                            break;
                    }
                });
                
                connection.addEventListener('iceconnectionstatechange', () => {
                    this.log(`üßä ICE connection state (${peerId}): ${connection.iceConnectionState}`, 'info');
                });
                
                connection.addEventListener('icegatheringstatechange', () => {
                    this.log(`üßä ICE gathering state (${peerId}): ${connection.iceGatheringState}`, 'info');
                });
                
                connection.addEventListener('icecandidate', (event) => {
                    if (event.candidate) {
                        this.log(`üßä New ICE candidate (${peerId}): ${event.candidate.type}`, 'info');
                    }
                });
                
                // Handle incoming data channels
                connection.addEventListener('datachannel', (event) => {
                    this.log(`üì° Incoming data channel (${peerId}): ${event.channel.label}`, 'info');
                    this.setupDataChannelHandlers(event.channel, peerId);
                });
            }
            
            setupDataChannelHandlers(channel, peerId) {
                channel.addEventListener('open', () => {
                    this.log(`üì° Data channel opened (${peerId}): ${channel.label}`, 'success');
                    this.dataChannels.set(peerId, channel);
                    
                    // Share file list once channel is open
                    setTimeout(() => {
                        this.shareFileList(peerId);
                    }, 100);
                });
                
                channel.addEventListener('close', () => {
                    this.log(`üì° Data channel closed (${peerId}): ${channel.label}`, 'warning');
                    this.dataChannels.delete(peerId);
                });
                
                channel.addEventListener('error', (error) => {
                    this.log(`üì° Data channel error (${peerId}): ${error}`, 'error');
                });
                
                channel.addEventListener('message', (event) => {
                    this.handleDataChannelMessage(event.data, peerId);
                });
            }
            
            handleConnectionEstablished(peerId, connection) {
                // Move from pending to active if it was pending
                if (this.pendingConnections.has(peerId)) {
                    this.pendingConnections.delete(peerId);
                }
                
                this.addPeer(peerId, connection);
                this.log(`ü§ù Connected to peer: ${peerId}`, 'success');
            }
            
            handleConnectionClosed(peerId) {
                this.removePeer(peerId);
                this.pendingConnections.delete(peerId);
                this.log(`‚ùå Disconnected from peer: ${peerId}`, 'warning');
            }
            
            displayOffer(offerJson) {
                const offerDisplay = document.getElementById('offerDisplay');
                const offerText = document.getElementById('offerText');
                
                offerText.textContent = offerJson;
                offerDisplay.classList.remove('hidden');
            }
            
            async handleOffer() {
                const btn = document.getElementById('connectBtn');
                const originalText = btn.innerHTML;
                
                try {
                    btn.innerHTML = '<div class="loading-spinner"></div> Processing...';
                    btn.disabled = true;
                    
                    const offerInput = document.getElementById('offerInput').value.trim();
                    if (!offerInput) {
                        throw new Error('Please paste an offer first');
                    }
                    
                    this.log('ü§ù Processing received offer...', 'info');
                    
                    const offerData = JSON.parse(offerInput);
                    const remotePeerId = offerData.peerId;
                    
                    if (remotePeerId === this.peerId) {
                        throw new Error('Cannot connect to yourself');
                    }
                    
                    const connection = new RTCPeerConnection(this.rtcConfig);
                    
                    // Set up connection event handlers
                    this.setupConnectionEventHandlers(connection, remotePeerId);
                    
                    // Set remote description first
                    await connection.setRemoteDescription(offerData.offer);
                    this.log('üì° Remote description set', 'info');
                    
                    // Create answer
                    const answer = await connection.createAnswer();
                    await connection.setLocalDescription(answer);
                    this.log('üì° Local description set, gathering ICE candidates...', 'info');
                    
                    // Wait for ICE gathering
                    await this.waitForICEGathering(connection);
                    
                    const answerData = {
                        type: 'answer',
                        peerId: this.peerId,
                        answer: connection.localDescription,
                        timestamp: Date.now()
                    };
                    
                    // Store the connection
                    this.connections.set(remotePeerId, connection);
                    
                    this.displayAnswer(JSON.stringify(answerData, null, 2));
                    this.log('‚úÖ Answer created successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to process offer: ${error.message}`, 'error');
                    console.error('Handle offer error:', error);
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
            
            displayAnswer(answerJson) {
                const answerDisplay = document.getElementById('answerDisplay');
                const answerText = document.getElementById('answerText');
                
                answerText.textContent = answerJson;
                answerDisplay.classList.remove('hidden');
            }
            
            async handleAnswer() {
                const btn = document.getElementById('finalizeBtn');
                const originalText = btn.innerHTML;
                
                try {
                    btn.innerHTML = '<div class="loading-spinner"></div> Finalizing...';
                    btn.disabled = true;
                    
                    const answerInput = document.getElementById('answerInput').value.trim();
                    if (!answerInput) {
                        throw new Error('Please paste an answer first');
                    }
                    
                    this.log('‚úÖ Processing received answer...', 'info');
                    
                    const answerData = JSON.parse(answerInput);
                    const remotePeerId = answerData.peerId;
                    
                    if (remotePeerId === this.peerId) {
                        throw new Error('Cannot connect to yourself');
                    }
                    
                    // Find the corresponding pending connection
                    let connection = null;
                    let tempId = null;
                    
                    for (const [id, pendingConn] of this.pendingConnections.entries()) {
                        if (pendingConn.type === 'offer') {
                            connection = pendingConn.connection;
                            tempId = id;
                            break;
                        }
                    }
                    
                    if (!connection) {
                        throw new Error('No pending offer found. Please create an offer first.');
                    }
                    
                    // Set remote description
                    await connection.setRemoteDescription(answerData.answer);
                    this.log('üì° Remote description set', 'info');
                    
                    // Move connection from pending to active
                    this.pendingConnections.delete(tempId);
                    this.connections.set(remotePeerId, connection);
                    
                    // Update event handlers to use real peer ID
                    this.setupConnectionEventHandlers(connection, remotePeerId);
                    
                    this.log('‚úÖ Connection finalized successfully', 'success');
                    
                    // Clear the input fields
                    document.getElementById('answerInput').value = '';
                    document.getElementById('offerInput').value = '';
                    
                    // Hide displays
                    document.getElementById('offerDisplay').classList.add('hidden');
                    document.getElementById('answerDisplay').classList.add('hidden');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to process answer: ${error.message}`, 'error');
                    console.error('Handle answer error:', error);
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
            
            handleDataChannelMessage(data, peerId) {
                try {
                    const message = JSON.parse(data);
                    
                    switch (message.type) {
                        case 'file-list':
                            this.handleFileListUpdate(message.files, peerId);
                            break;
                        case 'file-request':
                            this.handleFileRequest(message, peerId);
                            break;
                        case 'file-chunk':
                            this.handleFileChunk(message);
                            break;
                        case 'heartbeat':
                            this.handleHeartbeat(message, peerId);
                            break;
                        default:
                            this.log(`‚ùì Unknown message type: ${message.type}`, 'warning');
                    }
                } catch (error) {
                    this.log(`‚ùå Failed to parse message from ${peerId}: ${error.message}`, 'error');
                }
            }
            
            addPeer(peerId, connection) {
                this.peers.set(peerId, {
                    connection,
                    connected: true,
                    lastSeen: Date.now(),
                    files: new Map()
                });
                
                this.connections.set(peerId, connection);
                this.updateUI();
            }
            
            removePeer(peerId) {
                // Clean up peer data
                this.peers.delete(peerId);
                
                // Close and clean up connection
                const connection = this.connections.get(peerId);
                if (connection && connection.connectionState !== 'closed') {
                    connection.close();
                }
                this.connections.delete(peerId);
                
                // Clean up data channel
                const channel = this.dataChannels.get(peerId);
                if (channel && channel.readyState !== 'closed') {
                    channel.close();
                }
                this.dataChannels.delete(peerId);
                
                // Clean up stats
                this.connectionStats.delete(peerId);
                
                this.updateUI();
            }
            
            shareFileList(peerId) {
                const fileList = Array.from(this.sharedFiles.values()).map(file => ({
                    id: file.id,
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified
                }));
                
                this.sendMessage(peerId, {
                    type: 'file-list',
                    files: fileList,
                    peerId: this.peerId
                });
            }
            
            sendMessage(peerId, message) {
                const channel = this.dataChannels.get(peerId);
                if (channel && channel.readyState === 'open') {
                    try {
                        channel.send(JSON.stringify(message));
                        return true;
                    } catch (error) {
                        this.log(`‚ùå Failed to send message to ${peerId}: ${error.message}`, 'error');
                        return false;
                    }
                }
                return false;
            }
            
            handleFileSelection(files) {
                Array.from(files).forEach(file => {
                    const fileId = this.generateFileId(file);
                    this.sharedFiles.set(fileId, {
                        id: fileId,
                        file: file,
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified,
                        chunks: this.createFileChunks(file)
                    });
                    
                    this.log(`üìÅ Added file: ${file.name} (${this.formatBytes(file.size)})`, 'success');
                });
                
                this.updateSharedFilesUI();
                this.broadcastFileList();
            }
            
            generateFileId(file) {
                return `${file.name}_${file.size}_${file.lastModified}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            createFileChunks(file) {
                const chunks = [];
                const totalChunks = Math.ceil(file.size / this.chunkSize);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * this.chunkSize;
                    const end = Math.min(start + this.chunkSize, file.size);
                    chunks.push({
                        index: i,
                        start,
                        end,
                        size: end - start
                    });
                }
                
                return chunks;
            }
            
            broadcastFileList() {
                this.peers.forEach((peer, peerId) => {
                    if (peer.connected && this.dataChannels.has(peerId)) {
                        this.shareFileList(peerId);
                    }
                });
            }
            
            handleFileListUpdate(files, peerId) {
                const peer = this.peers.get(peerId);
                if (peer) {
                    peer.files.clear();
                    files.forEach(file => {
                        peer.files.set(file.id, file);
                    });
                    this.updateAvailableFilesUI();
                    this.log(`üìã Updated file list from ${peerId} (${files.length} files)`, 'info');
                }
            }
            
            async handleFileRequest(message, peerId) {
                const { fileId, chunkIndex } = message;
                const sharedFile = this.sharedFiles.get(fileId);
                
                if (!sharedFile) {
                    this.log(`‚ùå Requested file not found: ${fileId}`, 'error');
                    return;
                }
                
                const chunk = sharedFile.chunks[chunkIndex];
                if (!chunk) {
                    this.log(`‚ùå Requested chunk not found: ${chunkIndex}`, 'error');
                    return;
                }
                
                try {
                    const blob = sharedFile.file.slice(chunk.start, chunk.end);
                    const arrayBuffer = await blob.arrayBuffer();
                    const base64Data = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                    
                    const response = {
                        type: 'file-chunk',
                        fileId,
                        chunkIndex,
                        data: base64Data,
                        totalChunks: sharedFile.chunks.length
                    };
                    
                    this.sendMessage(peerId, response);
                    this.recordTransfer(peerId, 'upload', chunk.size);
                    
                } catch (error) {
                    this.log(`‚ùå Failed to send chunk: ${error.message}`, 'error');
                }
            }
            
            handleFileChunk(message) {
                const { fileId, chunkIndex, data, totalChunks } = message;
                
                if (!this.downloadingFiles.has(fileId)) {
                    this.log(`‚ùå Unexpected chunk for file: ${fileId}`, 'error');
                    return;
                }
                
                const download = this.downloadingFiles.get(fileId);
                
                try {
                    // Decode base64 data
                    const binaryString = atob(data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    download.chunks[chunkIndex] = bytes;
                    download.receivedChunks++;
                    
                    this.recordTransfer(download.peerId, 'download', bytes.length);
                    
                    // Update progress
                    const progress = (download.receivedChunks / totalChunks) * 100;
                    this.updateDownloadProgress(fileId, progress);
                    
                    if (download.receivedChunks === totalChunks) {
                        this.completeDownload(fileId);
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Failed to process chunk: ${error.message}`, 'error');
                }
            }
            
            handleHeartbeat(message, peerId) {
                const peer = this.peers.get(peerId);
                if (peer) {
                    peer.lastSeen = Date.now();
                }
            }
            
            async downloadFile(fileId, fileName, fileSize, peerId) {
                if (this.downloadingFiles.has(fileId)) {
                    this.log(`‚ùå File is already being downloaded: ${fileName}`, 'warning');
                    return;
                }
                
                if (this.downloadingFiles.size >= this.maxConcurrentDownloads) {
                    this.log(`‚ùå Maximum concurrent downloads reached (${this.maxConcurrentDownloads})`, 'warning');
                    return;
                }
                
                const totalChunks = Math.ceil(fileSize / this.chunkSize);
                const download = {
                    fileId,
                    fileName,
                    fileSize,
                    peerId,
                    totalChunks,
                    receivedChunks: 0,
                    chunks: new Array(totalChunks),
                    startTime: Date.now()
                };
                
                this.downloadingFiles.set(fileId, download);
                this.addDownloadUI(fileId, fileName, fileSize);
                
                this.log(`üì• Starting download: ${fileName} (${this.formatBytes(fileSize)})`, 'info');
                
                // Request chunks
                for (let i = 0; i < totalChunks; i++) {
                    this.sendMessage(peerId, {
                        type: 'file-request',
                        fileId,
                        chunkIndex: i,
                        peerId: this.peerId
                    });
                }
            }
            
            completeDownload(fileId) {
                const download = this.downloadingFiles.get(fileId);
                if (!download) return;
                
                try {
                    // Combine chunks in correct order
                    const totalSize = download.chunks.reduce((sum, chunk) => sum + (chunk ? chunk.length : 0), 0);
                    const combined = new Uint8Array(totalSize);
                    let offset = 0;
                    
                    for (let i = 0; i < download.chunks.length; i++) {
                        const chunk = download.chunks[i];
                        if (chunk) {
                            combined.set(chunk, offset);
                            offset += chunk.length;
                        }
                    }
                    
                    // Create blob and download
                    const blob = new Blob([combined]);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = download.fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // Clean up blob URL
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    this.downloadingFiles.delete(fileId);
                    this.removeDownloadUI(fileId);
                    
                    const duration = Date.now() - download.startTime;
                    this.log(`‚úÖ Download completed: ${download.fileName} (${this.formatBytes(download.fileSize)} in ${(duration/1000).toFixed(1)}s)`, 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to complete download: ${error.message}`, 'error');
                }
            }
            
            updateUI() {
                this.updateConnectionStatus();
                this.updatePeersList();
                this.updateStatsDisplay();
            }
            
            updateConnectionStatus() {
                const connectedPeers = Array.from(this.peers.values()).filter(p => p.connected).length;
                const connectionIndicator = document.getElementById('connectionIndicator');
                const connectionText = document.getElementById('connectionText');
                const peerCount = document.getElementById('peerCount');
                const transferStatus = document.getElementById('transferStatus');
                
                if (connectedPeers > 0) {
                    connectionIndicator.classList.add('connected');
                    connectionText.textContent = 'Connected';
                } else {
                    connectionIndicator.classList.remove('connected');
                    connectionText.textContent = 'Offline';
                }
                
                peerCount.textContent = `${connectedPeers} ${connectedPeers === 1 ? 'peer' : 'peers'}`;
                
                const activeDownloads = this.downloadingFiles.size;
                if (activeDownloads > 0) {
                    transferStatus.textContent = `${activeDownloads} active downloads`;
                } else {
                    transferStatus.textContent = 'Ready';
                }
            }
            
            updatePeersList() {
                const peerList = document.getElementById('peerList');
                const connectedPeers = Array.from(this.peers.entries()).filter(([_, peer]) => peer.connected);
                
                if (connectedPeers.length === 0) {
                    peerList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No peers connected. Use the connection manager above to join the network.</p>';
                    return;
                }
                
                peerList.innerHTML = connectedPeers.map(([peerId, peer]) => `
                    <div class="peer-item">
                        <div class="peer-info">
                            <div class="peer-status">
                                <div class="status-indicator connected"></div>
                                <span class="peer-id">${peerId.substring(0, 32)}...</span>
                            </div>
                            <div class="peer-details">
                                üìÅ ${peer.files.size} files ‚Ä¢ üïí Last seen: ${this.formatTime(peer.lastSeen)}
                            </div>
                        </div>
                        <div class="peer-actions">
                            <button class="btn btn-danger" onclick="p2pNode.disconnectPeer('${peerId}')" style="padding: 8px 16px; font-size: 0.9rem;">
                                üîå Disconnect
                            </button>
                        </div>
                    </div>
                `).join('');
            }
            
            updateSharedFilesUI() {
                const sharedFilesList = document.getElementById('sharedFilesList');
                const files = Array.from(this.sharedFiles.values());
                
                if (files.length === 0) {
                    sharedFilesList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No files shared yet. Drop files above to start sharing.</p>';
                    return;
                }
                
                sharedFilesList.innerHTML = files.map(file => `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-icon">üìÑ</div>
                            <div class="file-details">
                                <h4>${file.name}</h4>
                                <div class="file-meta">
                                    ${this.formatBytes(file.size)} ‚Ä¢ ${file.type || 'Unknown type'}
                                </div>
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="btn btn-danger" onclick="p2pNode.removeSharedFile('${file.id}')" style="padding: 8px 16px; font-size: 0.9rem;">
                                üóëÔ∏è Remove
                            </button>
                        </div>
                    </div>
                `).join('');
            }
            
            updateAvailableFilesUI() {
                const availableFiles = document.getElementById('availableFiles');
                const allFiles = [];
                
                this.peers.forEach((peer, peerId) => {
                    peer.files.forEach(file => {
                        allFiles.push({ ...file, peerId });
                    });
                });
                
                if (allFiles.length === 0) {
                    availableFiles.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Connect to peers to discover available files...</p>';
                    return;
                }
                
                availableFiles.innerHTML = allFiles.map(file => `
                    <div class="file-item" id="file-${file.id}">
                        <div class="file-info">
                            <div class="file-icon">üì•</div>
                            <div class="file-details">
                                <h4>${file.name}</h4>
                                <div class="file-meta">
                                    ${this.formatBytes(file.size)} ‚Ä¢ From: ${file.peerId.substring(0, 16)}...
                                </div>
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="btn btn-success" onclick="p2pNode.downloadFile('${file.id}', '${file.name}', ${file.size}, '${file.peerId}')" style="padding: 8px 16px; font-size: 0.9rem;">
                                üì• Download
                            </button>
                        </div>
                    </div>
                `).join('');
            }
            
            addDownloadUI(fileId, fileName, fileSize) {
                const fileItem = document.getElementById(`file-${fileId}`);
                if (fileItem) {
                    fileItem.innerHTML = `
                        <div class="file-info">
                            <div class="file-icon">üì•</div>
                            <div class="file-details">
                                <h4>üì• ${fileName}</h4>
                                <div class="file-meta">
                                    ${this.formatBytes(fileSize)} ‚Ä¢ Downloading...
                                </div>
                                <div class="progress-container">
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: 0%"></div>
                                    </div>
                                    <div class="progress-text">
                                        <span>0%</span>
                                        <span>0 / 0 chunks</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="btn btn-danger" onclick="p2pNode.cancelDownload('${fileId}')" style="padding: 8px 16px; font-size: 0.9rem;">
                                ‚ùå Cancel
                            </button>
                        </div>
                    `;
                }
            }
            
            updateDownloadProgress(fileId, progress) {
                const fileItem = document.getElementById(`file-${fileId}`);
                if (fileItem) {
                    const progressFill = fileItem.querySelector('.progress-fill');
                    const progressText = fileItem.querySelector('.progress-text');
                    const download = this.downloadingFiles.get(fileId);
                    
                    if (progressFill) {
                        progressFill.style.width = `${progress}%`;
                    }
                    
                    if (progressText && download) {
                        progressText.innerHTML = `
                            <span>${progress.toFixed(1)}%</span>
                            <span>${download.receivedChunks} / ${download.totalChunks} chunks</span>
                        `;
                    }
                }
            }
            
            removeDownloadUI(fileId) {
                // Refresh the available files UI to remove the download progress
                this.updateAvailableFilesUI();
            }
            
            removeSharedFile(fileId) {
                this.sharedFiles.delete(fileId);
                this.updateSharedFilesUI();
                this.broadcastFileList();
                this.log(`üóëÔ∏è Removed shared file`, 'info');
            }
            
            cancelDownload(fileId) {
                this.downloadingFiles.delete(fileId);
                this.removeDownloadUI(fileId);
                this.log(`‚ùå Cancelled download`, 'warning');
            }
            
            disconnectPeer(peerId) {
                this.removePeer(peerId);
                this.log(`üîå Disconnected from peer: ${peerId}`, 'info');
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            formatTime(timestamp) {
                const diff = Date.now() - timestamp;
                const seconds = Math.floor(diff / 1000);
                
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }
            
            copyToClipboard(elementId) {
                const element = document.getElementById(elementId);
                const text = element.textContent;
                
                navigator.clipboard.writeText(text).then(() => {
                    this.showToast('üìã Copied to clipboard!', 'success');
                }).catch(err => {
                    this.log(`‚ùå Failed to copy: ${err.message}`, 'error');
                });
            }
            
            copyOfferToClipboard() {
                const offerText = document.getElementById('offerText').textContent;
                navigator.clipboard.writeText(offerText).then(() => {
                    this.showToast('üìã Offer copied to clipboard!', 'success');
                }).catch(err => {
                    this.log(`‚ùå Failed to copy offer: ${err.message}`, 'error');
                });
            }
            
            copyAnswerToClipboard() {
                const answerText = document.getElementById('answerText').textContent;
                navigator.clipboard.writeText(answerText).then(() => {
                    this.showToast('üìã Answer copied to clipboard!', 'success');
                }).catch(err => {
                    this.log(`‚ùå Failed to copy answer: ${err.message}`, 'error');
                });
            }
        }
        
        // Initialize the P2P node when the page loads
        let p2pNode;
        
        document.addEventListener('DOMContentLoaded', () => {
            p2pNode = new AdvancedP2PNode();
        });
    </script>
</body>
</html>