<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced P2P Torrent System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .peer-info {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .peer-id {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin-bottom: 20px;
            position: relative;
            word-break: break-all;
            border: 2px solid #e9ecef;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .status-card h4 {
            font-size: 14px;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .status-card p {
            font-size: 18px;
            font-weight: bold;
        }

        .network-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connection-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .connection-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .connection-box h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3rem;
        }

        .file-section, .peers-section, .log-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .file-input-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9ff;
            margin-bottom: 20px;
        }

        .file-input-area:hover, .file-input-area.drag-over {
            border-color: #764ba2;
            background: #f0f4ff;
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545, #fd7e14);
            color: white;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .offer-display {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 15px;
            position: relative;
            max-height: 200px;
            overflow-y: auto;
            word-break: break-all;
            border: 2px solid #e9ecef;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .copy-btn:hover {
            background: #764ba2;
        }

        .file-list {
            margin-top: 20px;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }

        .file-details {
            font-size: 12px;
            color: #6c757d;
        }

        .file-actions {
            display: flex;
            gap: 10px;
        }

        .peer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #e9ecef;
        }

        .peer-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #dc3545;
            animation: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .log-section {
            max-height: 300px;
        }

        #logEntries {
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.warning {
            color: #ffc107;
        }

        .log-entry.info {
            color: #17a2b8;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            border-left: 4px solid #667eea;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left-color: #28a745;
        }

        .toast.error {
            border-left-color: #dc3545;
        }

        .toast.warning {
            border-left-color: #ffc107;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .connection-section {
                grid-template-columns: 1fr;
            }
            
            .status-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .network-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Advanced P2P Torrent System</h1>
            <p>WebRTC-based Decentralized File Sharing with Enhanced Features</p>
        </div>
        
        <div class="peer-info">
            <h3>Your Node Information</h3>
            <div class="peer-id" id="myPeerId">
                Generating secure peer ID...
                <button class="copy-btn" onclick="p2pNode.copyToClipboard('myPeerId')">Copy</button>
            </div>
            <div class="status-grid">
                <div class="status-card" id="connectionStatus">
                    <h4>Connection</h4>
                    <p id="connectionText">Initializing...</p>
                </div>
                <div class="status-card" id="peerStatus">
                    <h4>Active Peers</h4>
                    <p id="peerCount">0 connected</p>
                </div>
                <div class="status-card" id="downloadStatus">
                    <h4>Downloads</h4>
                    <p id="downloadCount">0 active</p>
                </div>
                <div class="status-card" id="uploadStatus">
                    <h4>Shared Files</h4>
                    <p id="uploadCount">0 files</p>
                </div>
            </div>
            
            <div class="network-stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalUploaded">0 B</div>
                    <div class="stat-label">Total Uploaded</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalDownloaded">0 B</div>
                    <div class="stat-label">Total Downloaded</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="uploadSpeed">0 B/s</div>
                    <div class="stat-label">Upload Speed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="downloadSpeed">0 B/s</div>
                    <div class="stat-label">Download Speed</div>
                </div>
            </div>
        </div>
        
        <div class="connection-section">
            <div class="connection-box">
                <h3>üéØ Create Connection</h3>
                <p>Generate an offer to share with another peer:</p>
                <button class="btn btn-primary" id="createOfferBtn">Generate Secure Offer</button>
                <div class="offer-display" id="offerDisplay" style="display: none;">
                    <button class="copy-btn" onclick="p2pNode.copyToClipboard('offerDisplay')">Copy</button>
                </div>
            </div>
            
            <div class="connection-box">
                <h3>üîó Join Network</h3>
                <p>Paste an offer from another peer to connect:</p>
                <div class="input-group">
                    <textarea class="input-field" id="offerInput" placeholder="Paste the complete offer JSON here..." rows="4"></textarea>
                </div>
                <button class="btn btn-primary" id="connectBtn">Connect to Peer</button>
                <div class="offer-display" id="answerDisplay" style="display: none;">
                    <button class="copy-btn" onclick="p2pNode.copyToClipboard('answerDisplay')">Copy</button>
                </div>
            </div>
        </div>
        
        <div class="connection-section">
            <div class="connection-box">
                <h3>‚úÖ Complete Connection</h3>
                <p>If you created an offer, paste the answer here to finalize:</p>
                <div class="input-group">
                    <textarea class="input-field" id="answerInput" placeholder="Paste the answer JSON here..." rows="4"></textarea>
                </div>
                <button class="btn btn-success" id="finalizeBtn">Finalize Connection</button>
            </div>
        </div>
        
        <div class="file-section">
            <h3>üì§ Share Files</h3>
            <div class="file-input-area" id="fileDropArea">
                <p>üìÅ Drop files here or click to select</p>
                <p style="font-size: 14px; color: #6c757d; margin-top: 10px;">Supports any file type ‚Ä¢ Automatic chunking for large files</p>
                <button class="btn btn-primary" style="margin-top: 15px;">Select Files</button>
                <input type="file" id="fileInput" class="file-input" multiple>
            </div>
            
            <div class="file-list" id="sharedFiles">
                <h4>Your Shared Files:</h4>
            </div>
        </div>
        
        <div class="file-section">
            <h3>üì• Available Downloads</h3>
            <div class="file-list" id="availableFiles">
                <p>Connect to peers to discover available files...</p>
            </div>
        </div>
        
        <div class="peers-section">
            <h3>üë• Network Peers</h3>
            <div class="peer-list" id="peerList">
                <p>No peers connected. Use the connection section above to join the network.</p>
            </div>
        </div>
        
        <div class="log-section" id="logSection">
            <h4>üìä System Activity Log</h4>
            <div id="logEntries"></div>
        </div>
    </div>

    <script>
        class AdvancedP2PNode {
            constructor() {
                this.peerId = this.generateSecurePeerId();
                this.peers = new Map();
                this.connections = new Map();
                this.dataChannels = new Map();
                this.sharedFiles = new Map();
                this.downloadingFiles = new Map();
                this.fileChunks = new Map();
                this.pendingOffers = new Map();
                this.connectionStats = new Map();
                
                // Enhanced configuration
                this.chunkSize = 32 * 1024; // 32KB chunks for better performance
                this.maxChunksPerRequest = 8;
                this.maxConcurrentDownloads = 3;
                this.heartbeatInterval = 30000; // 30 seconds
                this.connectionTimeout = 60000; // 60 seconds
                
                // Statistics tracking
                this.stats = {
                    totalUploaded: 0,
                    totalDownloaded: 0,
                    uploadSpeed: 0,
                    downloadSpeed: 0,
                    sessionStart: Date.now()
                };
                
                this.init();
            }
            
            generateSecurePeerId() {
                // Generate a more secure and readable peer ID
                const timestamp = Date.now().toString(36);
                const random = Array.from(crypto.getRandomValues(new Uint8Array(12)))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                return `peer_${timestamp}_${random}`;
            }
            
            init() {
                this.log('üöÄ Advanced P2P Node initializing...', 'info');
                this.updatePeerIdDisplay();
                this.setupEventListeners();
                this.startHeartbeat();
                this.startStatsUpdate();
                this.updateUI();
                this.log('‚úÖ Node initialization complete', 'success');
            }
            
            updatePeerIdDisplay() {
                document.getElementById('myPeerId').innerHTML = `
                    ${this.peerId}
                    <button class="copy-btn" onclick="p2pNode.copyToClipboard('myPeerId')">Copy</button>
                `;
            }
            
            log(message, type = 'info') {
                const logEntries = document.getElementById('logEntries');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logEntries.appendChild(entry);
                logEntries.scrollTop = logEntries.scrollHeight;
                
                // Keep only last 200 entries
                while (logEntries.children.length > 200) {
                    logEntries.removeChild(logEntries.firstChild);
                }
                
                console.log(`[P2P] ${message}`);
                
                // Show toast for important events
                if (type === 'success' || type === 'error' || type === 'warning') {
                    this.showToast(message, type);
                }
            }
            
            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => document.body.removeChild(toast), 300);
                }, 3000);
            }
            
            startHeartbeat() {
                setInterval(() => {
                    this.peers.forEach((peer, peerId) => {
                        if (peer.connected) {
                            this.sendMessage(peerId, {
                                type: 'heartbeat',
                                timestamp: Date.now()
                            });
                        }
                    });
                }, this.heartbeatInterval);
            }
            
            startStatsUpdate() {
                setInterval(() => {
                    this.updateStats();
                }, 1000);
            }
            
            updateStats() {
                // Calculate current speeds based on recent transfers
                const now = Date.now();
                const timeWindow = 5000; // 5 second window
                
                let recentUploaded = 0;
                let recentDownloaded = 0;
                
                this.connectionStats.forEach(stats => {
                    const recentTransfers = stats.transfers.filter(t => now - t.timestamp < timeWindow);
                    recentUploaded += recentTransfers.filter(t => t.type === 'upload').reduce((sum, t) => sum + t.bytes, 0);
                    recentDownloaded += recentTransfers.filter(t => t.type === 'download').reduce((sum, t) => sum + t.bytes, 0);
                });
                
                this.stats.uploadSpeed = recentUploaded / (timeWindow / 1000);
                this.stats.downloadSpeed = recentDownloaded / (timeWindow / 1000);
                
                this.updateStatsDisplay();
            }
            
            updateStatsDisplay() {
                document.getElementById('totalUploaded').textContent = this.formatBytes(this.stats.totalUploaded);
                document.getElementById('totalDownloaded').textContent = this.formatBytes(this.stats.totalDownloaded);
                document.getElementById('uploadSpeed').textContent = this.formatBytes(this.stats.uploadSpeed) + '/s';
                document.getElementById('downloadSpeed').textContent = this.formatBytes(this.stats.downloadSpeed) + '/s';
            }
            
            recordTransfer(peerId, type, bytes) {
                if (!this.connectionStats.has(peerId)) {
                    this.connectionStats.set(peerId, {
                        transfers: [],
                        totalUploaded: 0,
                        totalDownloaded: 0
                    });
                }
                
                const stats = this.connectionStats.get(peerId);
                stats.transfers.push({
                    type,
                    bytes,
                    timestamp: Date.now()
                });
                
                // Keep only recent transfers
                const cutoff = Date.now() - 60000; // 1 minute
                stats.transfers = stats.transfers.filter(t => t.timestamp > cutoff);
                
                if (type === 'upload') {
                    stats.totalUploaded += bytes;
                    this.stats.totalUploaded += bytes;
                } else {
                    stats.totalDownloaded += bytes;
                    this.stats.totalDownloaded += bytes;
                }
            }
            
            setupEventListeners() {
                // WebRTC connection setup
                document.getElementById('createOfferBtn').addEventListener('click', () => this.createOffer());
                document.getElementById('connectBtn').addEventListener('click', () => this.handleOffer());
                document.getElementById('finalizeBtn').addEventListener('click', () => this.handleAnswer());
                
                // File handling
                const fileInput = document.getElementById('fileInput');
                const fileDropArea = document.getElementById('fileDropArea');
                
                fileDropArea.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleFileSelection(e.target.files));
                
                // Enhanced drag and drop
                fileDropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    fileDropArea.classList.add('drag-over');
                });
                
                fileDropArea.addEventListener('dragleave', (e) => {
                    if (!fileDropArea.contains(e.relatedTarget)) {
                        fileDropArea.classList.remove('drag-over');
                    }
                });
                
                fileDropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    fileDropArea.classList.remove('drag-over');
                    this.handleFileSelection(e.dataTransfer.files);
                });
            }
            
            async createOffer() {
                try {
                    this.log('Creating WebRTC offer...', 'info');
                    
                    const connection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Create data channel for file transfers
                    const dataChannel = connection.createDataChannel('fileTransfer', {
                        ordered: true,
                        maxPacketLifeTime: 3000
                    });
                    
                    this.setupDataChannel(dataChannel);
                    
                    const offer = await connection.createOffer();
                    await connection.setLocalDescription(offer);
                    
                    // Wait for ICE gathering to complete
                    await new Promise((resolve) => {
                        if (connection.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            connection.addEventListener('icegatheringstatechange', () => {
                                if (connection.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            });
                        }
                    });
                    
                    const offerData = {
                        type: 'offer',
                        peerId: this.peerId,
                        offer: connection.localDescription,
                        timestamp: Date.now()
                    };
                    
                    const tempPeerId = `temp_${Date.now()}`;
                    this.connections.set(tempPeerId, connection);
                    this.pendingOffers.set(tempPeerId, offerData);
                    
                    this.displayOffer(JSON.stringify(offerData, null, 2));
                    this.log('‚úÖ Offer created successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to create offer: ${error.message}`, 'error');
                }
            }
            
            displayOffer(offerJson) {
                const offerDisplay = document.getElementById('offerDisplay');
                offerDisplay.innerHTML = `
                    <pre>${offerJson}</pre>
                    <button class="copy-btn" onclick="p2pNode.copyToClipboard('offerDisplay')">Copy</button>
                `;
                offerDisplay.style.display = 'block';
            }
            
            async handleOffer() {
                try {
                    const offerInput = document.getElementById('offerInput').value.trim();
                    if (!offerInput) {
                        this.log('‚ùå Please paste an offer first', 'error');
                        return;
                    }
                    
                    this.log('Processing received offer...', 'info');
                    
                    const offerData = JSON.parse(offerInput);
                    const remotePeerId = offerData.peerId;
                    
                    const connection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Set up data channel handling
                    connection.addEventListener('datachannel', (event) => {
                        this.log(`üì° Data channel received: ${event.channel.label}`, 'info');
                        this.setupDataChannel(event.channel);
                    });
                    
                    await connection.setRemoteDescription(offerData.offer);
                    const answer = await connection.createAnswer();
                    await connection.setLocalDescription(answer);
                    
                    // Wait for ICE gathering
                    await new Promise((resolve) => {
                        if (connection.iceGatheringState === 'complete') {
                            resolve();
                        } else {
                            connection.addEventListener('icegatheringstatechange', () => {
                                if (connection.iceGatheringState === 'complete') {
                                    resolve();
                                }
                            });
                        }
                    });
                    
                    const answerData = {
                        type: 'answer',
                        peerId: this.peerId,
                        answer: connection.localDescription,
                        timestamp: Date.now()
                    };
                    
                    this.connections.set(remotePeerId, connection);
                    this.setupConnectionEvents(connection, remotePeerId);
                    
                    this.displayAnswer(JSON.stringify(answerData, null, 2));
                    this.log('‚úÖ Answer created successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to process offer: ${error.message}`, 'error');
                }
            }
            
            displayAnswer(answerJson) {
                const answerDisplay = document.getElementById('answerDisplay');
                answerDisplay.innerHTML = `
                    <pre>${answerJson}</pre>
                    <button class="copy-btn" onclick="p2pNode.copyToClipboard('answerDisplay')">Copy</button>
                `;
                answerDisplay.style.display = 'block';
            }
            
            async handleAnswer() {
                try {
                    const answerInput = document.getElementById('answerInput').value.trim();
                    if (!answerInput) {
                        this.log('‚ùå Please paste an answer first', 'error');
                        return;
                    }
                    
                    this.log('Processing received answer...', 'info');
                    
                    const answerData = JSON.parse(answerInput);
                    const remotePeerId = answerData.peerId;
                    
                    // Find the corresponding connection
                    let connection = null;
                    let tempPeerId = null;
                    
                    for (const [id, conn] of this.connections.entries()) {
                        if (id.startsWith('temp_')) {
                            connection = conn;
                            tempPeerId = id;
                            break;
                        }
                    }
                    
                    if (!connection) {
                        this.log('‚ùå No pending offer found', 'error');
                        return;
                    }
                    
                    await connection.setRemoteDescription(answerData.answer);
                    
                    // Move connection to proper peer ID
                    this.connections.delete(tempPeerId);
                    this.connections.set(remotePeerId, connection);
                    this.pendingOffers.delete(tempPeerId);
                    
                    this.setupConnectionEvents(connection, remotePeerId);
                    
                    this.log('‚úÖ Connection finalized successfully', 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Failed to process answer: ${error.message}`, 'error');
                }
            }
            
            setupConnectionEvents(connection, peerId) {
                connection.addEventListener('connectionstatechange', () => {
                    this.log(`Connection state changed: ${connection.connectionState}`, 'info');
                    if (connection.connectionState === 'connected') {
                        this.addPeer(peerId, connection);
                        this.log(`ü§ù Connected to peer: ${peerId}`, 'success');
                    } else if (connection.connectionState === 'disconnected' || connection.connectionState === 'failed') {
                        this.removePeer(peerId);
                        this.log(`‚ùå Disconnected from peer: ${peerId}`, 'warning');
                    }
                });
                
                connection.addEventListener('iceconnectionstatechange', () => {
                    this.log(`ICE connection state: ${connection.iceConnectionState}`, 'info');
                });
            }
            
            setupDataChannel(channel) {
                channel.addEventListener('open', () => {
                    this.log(`üì° Data channel opened: ${channel.label}`, 'success');
                });
                
                channel.addEventListener('close', () => {
                    this.log(`üì° Data channel closed: ${channel.label}`, 'warning');
                });
                
                channel.addEventListener('error', (error) => {
                    this.log(`üì° Data channel error: ${error}`, 'error');
                });
                
                channel.addEventListener('message', (event) => {
                    this.handleDataChannelMessage(event.data, channel);
                });
            }
            
            handleDataChannelMessage(data, channel) {
                try {
                    const message = JSON.parse(data);
                    
                    switch (message.type) {
                        case 'file-list':
                            this.handleFileListUpdate(message.files, message.peerId);
                            break;
                        case 'file-request':
                            this.handleFileRequest(message, channel);
                            break;
                        case 'file-chunk':
                            this.handleFileChunk(message);
                            break;
                        case 'heartbeat':
                            this.handleHeartbeat(message);
                            break;
                        case 'file-info':
                            this.handleFileInfo(message);
                            break;
                        default:
                            this.log(`Unknown message type: ${message.type}`, 'warning');
                    }
                } catch (error) {
                    this.log(`Failed to parse message: ${error.message}`, 'error');
                }
            }
            
            addPeer(peerId, connection) {
                this.peers.set(peerId, {
                    connection,
                    connected: true,
                    lastSeen: Date.now(),
                    files: new Map()
                });
                
                // Get data channel
                const dataChannel = connection.createDataChannel('fileTransfer', {
                    ordered: true,
                    maxPacketLifeTime: 3000
                });
                
                this.setupDataChannel(dataChannel);
                this.dataChannels.set(peerId, dataChannel);
                
                this.updateUI();
                this.shareFileList(peerId);
            }
            
            removePeer(peerId) {
                this.peers.delete(peerId);
                this.connections.delete(peerId);
                this.dataChannels.delete(peerId);
                this.connectionStats.delete(peerId);
                this.updateUI();
            }
            
            shareFileList(peerId) {
                const fileList = Array.from(this.sharedFiles.values()).map(file => ({
                    id: file.id,
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: file.lastModified
                }));
                
                this.sendMessage(peerId, {
                    type: 'file-list',
                    files: fileList,
                    peerId: this.peerId
                });
            }
            
            sendMessage(peerId, message) {
                const channel = this.dataChannels.get(peerId);
                if (channel && channel.readyState === 'open') {
                    try {
                        channel.send(JSON.stringify(message));
                        return true;
                    } catch (error) {
                        this.log(`Failed to send message to ${peerId}: ${error.message}`, 'error');
                        return false;
                    }
                }
                return false;
            }
            
            handleFileSelection(files) {
                Array.from(files).forEach(file => {
                    const fileId = this.generateFileId(file);
                    this.sharedFiles.set(fileId, {
                        id: fileId,
                        file: file,
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        lastModified: file.lastModified,
                        chunks: this.createFileChunks(file)
                    });
                    
                    this.log(`üìÅ Added file: ${file.name} (${this.formatBytes(file.size)})`, 'success');
                });
                
                this.updateSharedFilesUI();
                this.broadcastFileList();
            }
            
            generateFileId(file) {
                return `${file.name}_${file.size}_${file.lastModified}_${Math.random().toString(36).substr(2, 9)}`;
            }
            
            createFileChunks(file) {
                const chunks = [];
                const totalChunks = Math.ceil(file.size / this.chunkSize);
                
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * this.chunkSize;
                    const end = Math.min(start + this.chunkSize, file.size);
                    chunks.push({
                        index: i,
                        start,
                        end,
                        size: end - start
                    });
                }
                
                return chunks;
            }
            
            broadcastFileList() {
                this.peers.forEach((peer, peerId) => {
                    if (peer.connected) {
                        this.shareFileList(peerId);
                    }
                });
            }
            
            handleFileListUpdate(files, peerId) {
                const peer = this.peers.get(peerId);
                this.log(`handleFileListUpdate: ${peer}`, 'info');
                if (peer) {
                    peer.files.clear();
                    files.forEach(file => {
                        peer.files.set(file.id, file);
                    });
                    this.updateAvailableFilesUI();
                    this.log(`üìã Updated file list from ${peerId} (${files.length} files)`, 'info');
                }
            }
            
            async handleFileRequest(message, channel) {
                const { fileId, chunkIndex } = message;
                this.log(`handleFileRequest: ${fileId}:${chunkIndex}`, 'info');
                const sharedFile = this.sharedFiles.get(fileId);
                
                if (!sharedFile) {
                    this.log(`‚ùå Requested file not found: ${fileId}`, 'error');
                    return;
                }
                
                const chunk = sharedFile.chunks[chunkIndex];
                if (!chunk) {
                    this.log(`‚ùå Requested chunk not found: ${chunkIndex}`, 'error');
                    return;
                }
                
                try {
                    const blob = sharedFile.file.slice(chunk.start, chunk.end);
                    const arrayBuffer = await blob.arrayBuffer();
                    const base64Data = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                    
                    const response = {
                        type: 'file-chunk',
                        fileId,
                        chunkIndex,
                        data: base64Data,
                        totalChunks: sharedFile.chunks.length
                    };
                    
                    channel.send(JSON.stringify(response));
                    this.recordTransfer(message.peerId, 'upload', chunk.size);
                    
                } catch (error) {
                    this.log(`‚ùå Failed to send chunk: ${error.message}`, 'error');
                }
            }
            
            handleFileChunk(message) {
                const { fileId, chunkIndex, data, totalChunks } = message;
                this.log(`handleFileChunk: ${fileId}:${chunkIndex}`, 'info');
                
                if (!this.downloadingFiles.has(fileId)) {
                    this.log(`‚ùå Unexpected chunk for file: ${fileId}`, 'error');
                    return;
                }
                
                const download = this.downloadingFiles.get(fileId);
                
                // Decode base64 data
                const binaryString = atob(data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                download.chunks[chunkIndex] = bytes;
                download.receivedChunks++;
                
                this.recordTransfer(download.peerId, 'download', bytes.length);
                
                // Update progress
                const progress = (download.receivedChunks / totalChunks) * 100;
                this.updateDownloadProgress(fileId, progress);
                
                if (download.receivedChunks === totalChunks) {
                    this.completeDownload(fileId);
                }
                
                this.log(`üì¶ Received chunk ${chunkIndex + 1}/${totalChunks} for ${download.fileName}`, 'info');
            }
            
            async downloadFile(fileId, fileName, fileSize, peerId) {
                if (this.downloadingFiles.has(fileId)) {
                    this.log(`‚ùå File is already being downloaded: ${fileName}`, 'warning');
                    return;
                }
                
                const totalChunks = Math.ceil(fileSize / this.chunkSize);
                const download = {
                    fileId,
                    fileName,
                    fileSize,
                    peerId,
                    totalChunks,
                    receivedChunks: 0,
                    chunks: new Array(totalChunks),
                    startTime: Date.now()
                };
                
                this.downloadingFiles.set(fileId, download);
                this.addDownloadUI(fileId, fileName, fileSize);
                
                this.log(`üì• Starting download: ${fileName} (${this.formatBytes(fileSize)})`, 'info');
                
                // Request chunks
                for (let i = 0; i < totalChunks; i++) {
                    this.sendMessage(peerId, {
                        type: 'file-request',
                        fileId,
                        chunkIndex: i,
                        peerId: this.peerId
                    });
                }
            }
            
            completeDownload(fileId) {
                const download = this.downloadingFiles.get(fileId);
                if (!download) return;
                
                // Combine chunks
                const totalSize = download.chunks.reduce((sum, chunk) => sum + chunk.length, 0);
                const combined = new Uint8Array(totalSize);
                let offset = 0;
                
                for (const chunk of download.chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Create blob and download
                const blob = new Blob([combined]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = download.fileName;
                a.click();
                
                URL.revokeObjectURL(url);
                
                this.downloadingFiles.delete(fileId);
                this.removeDownloadUI(fileId);
                
                const duration = Date.now() - download.startTime;
                this.log(`‚úÖ Download completed: ${download.fileName} (${this.formatBytes(download.fileSize)} in ${(duration/1000).toFixed(1)}s)`, 'success');
            }
            
            handleHeartbeat(message) {
                const peerId = message.peerId;
                const peer = this.peers.get(peerId);
                if (peer) {
                    peer.lastSeen = Date.now();
                }
            }
            
            updateUI() {
                this.updateConnectionStatus();
                this.updatePeersList();
                this.updateCounters();
            }
            
            updateConnectionStatus() {
                const connectedPeers = Array.from(this.peers.values()).filter(p => p.connected).length;
                const connectionText = document.getElementById('connectionText');
                const peerCount = document.getElementById('peerCount');
                
                if (connectedPeers > 0) {
                    connectionText.textContent = 'Connected';
                    connectionText.style.color = '#28a745';
                } else {
                    connectionText.textContent = 'Disconnected';
                    connectionText.style.color = '#dc3545';
                }
                
                peerCount.textContent = `${connectedPeers} connected`;
            }
            
            updatePeersList() {
                const peerList = document.getElementById('peerList');
                const connectedPeers = Array.from(this.peers.entries()).filter(([_, peer]) => peer.connected);
                
                if (connectedPeers.length === 0) {
                    peerList.innerHTML = '<p>No peers connected. Use the connection section above to join the network.</p>';
                    return;
                }
                
                peerList.innerHTML = connectedPeers.map(([peerId, peer]) => `
                    <div class="peer-item">
                        <div class="peer-info">
                            <div class="peer-status">
                                <div class="status-indicator"></div>
                                <span class="peer-id">${peerId}</span>
                            </div>
                            <div class="peer-details">
                                Files: ${peer.files.size} ‚Ä¢ Last seen: ${this.formatTime(peer.lastSeen)}
                            </div>
                        </div>
                        <div class="peer-actions">
                            <button class="btn btn-danger" onclick="p2pNode.disconnectPeer('${peerId}')">Disconnect</button>
                        </div>
                    </div>
                `).join('');
            }
            
            updateCounters() {
                document.getElementById('downloadCount').textContent = `${this.downloadingFiles.size} active`;
                document.getElementById('uploadCount').textContent = `${this.sharedFiles.size} files`;
            }
            
            updateSharedFilesUI() {
                const sharedFilesDiv = document.getElementById('sharedFiles');
                const files = Array.from(this.sharedFiles.values());
                
                if (files.length === 0) {
                    sharedFilesDiv.innerHTML = '<h4>Your Shared Files:</h4><p>No files shared yet.</p>';
                    return;
                }
                
                sharedFilesDiv.innerHTML = `
                    <h4>Your Shared Files:</h4>
                    ${files.map(file => `
                        <div class="file-item">
                            <div class="file-info">
                                <div class="file-name">${file.name}</div>
                                <div class="file-details">
                                    ${this.formatBytes(file.size)} ‚Ä¢ ${file.type || 'Unknown type'}
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn btn-danger" onclick="p2pNode.removeSharedFile('${file.id}')">Remove</button>
                            </div>
                        </div>
                    `).join('')}
                `;
            }
            
            updateAvailableFilesUI() {
                const availableFilesDiv = document.getElementById('availableFiles');
                const allFiles = [];
                
                this.peers.forEach((peer, peerId) => {
                    peer.files.forEach(file => {
                        allFiles.push({ ...file, peerId });
                    });
                });
                
                if (allFiles.length === 0) {
                    availableFilesDiv.innerHTML = '<p>Connect to peers to discover available files...</p>';
                    return;
                }
                
                availableFilesDiv.innerHTML = allFiles.map(file => `
                    <div class="file-item">
                        <div class="file-info">
                            <div class="file-name">${file.name}</div>
                            <div class="file-details">
                                ${this.formatBytes(file.size)} ‚Ä¢ From: ${file.peerId}
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="btn btn-primary" onclick="p2pNode.downloadFile('${file.id}', '${file.name}', ${file.size}, '${file.peerId}')">Download</button>
                        </div>
                    </div>
                `).join('');
            }
            
            addDownloadUI(fileId, fileName, fileSize) {
                const availableFilesDiv = document.getElementById('availableFiles');
                const downloadItem = document.createElement('div');
                downloadItem.className = 'file-item';
                downloadItem.id = `download-${fileId}`;
                downloadItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">üì• ${fileName}</div>
                        <div class="file-details">
                            ${this.formatBytes(fileSize)} ‚Ä¢ Downloading...
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="file-actions">
                        <button class="btn btn-danger" onclick="p2pNode.cancelDownload('${fileId}')">Cancel</button>
                    </div>
                `;
                availableFilesDiv.appendChild(downloadItem);
            }
            
            updateDownloadProgress(fileId, progress) {
                const downloadItem = document.getElementById(`download-${fileId}`);
                if (downloadItem) {
                    const progressFill = downloadItem.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = `${progress}%`;
                    }
                }
            }
            
            removeDownloadUI(fileId) {
                const downloadItem = document.getElementById(`download-${fileId}`);
                if (downloadItem) {
                    downloadItem.remove();
                }
            }
            
            removeSharedFile(fileId) {
                this.sharedFiles.delete(fileId);
                this.updateSharedFilesUI();
                this.broadcastFileList();
                this.log(`üóëÔ∏è Removed shared file: ${fileId}`, 'info');
            }
            
            cancelDownload(fileId) {
                this.downloadingFiles.delete(fileId);
                this.removeDownloadUI(fileId);
                this.log(`‚ùå Cancelled download: ${fileId}`, 'warning');
            }
            
            disconnectPeer(peerId) {
                const connection = this.connections.get(peerId);
                if (connection) {
                    connection.close();
                }
                this.removePeer(peerId);
                this.log(`üîå Disconnected from peer: ${peerId}`, 'info');
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            formatTime(timestamp) {
                const diff = Date.now() - timestamp;
                const seconds = Math.floor(diff / 1000);
                
                if (seconds < 60) return `${seconds}s ago`;
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes}m ago`;
                const hours = Math.floor(minutes / 60);
                return `${hours}h ago`;
            }
            
            copyToClipboard(elementId) {
                const element = document.getElementById(elementId);
                const text = element.tagName.toUpperCase() === 'PRE' ? element.textContent : element.innerText.split('\n')[0];
                // const text = element.textContent;
                
                navigator.clipboard.writeText(text).then(() => {
                    this.showToast('Copied to clipboard!', 'success');
                }).catch(err => {
                    this.log(`Failed to copy: ${err.message}`, 'error');
                });
            }
        }
        
        // Initialize the P2P node when the page loads
        let p2pNode;
        
        document.addEventListener('DOMContentLoaded', () => {
            p2pNode = new AdvancedP2PNode();
        });
    </script>
</body>
</html>